\documentclass[12pt,letterpaper]{article}

\usepackage[left=1in,right=1.0in,top=1.0in,bottom=1.0in,
           includehead=true,headsep=1.0in,includefoot=true]{geometry}
\usepackage{setspace}
\usepackage{url}
\usepackage{tikz}
\usetikzlibrary{positioning,shapes,arrows}

\title{
  Clinical Decision Support for OpenMRS
}
\author{
        Bierman, Robert,  \emph{Group Lead}  \\ \texttt{bierman@mail.sfsu.edu} \and 
        Woeltjen, Victor, \emph{Group Lead}  \\ \texttt{woeltjan@mail.sfsu.edu} \and
        Choi, Kay       \and
        Gimeno, Steven  \and
        Lum, Jason      \and
        Ng, Ying Kit    \and
        Uy, Bianca      
} 



\begin{document}


\newpage 

\maketitle
\begin{center}
\begin{Large}\emph{Group 1:} Final Project for CSC 668-868 Spring 2013\end{Large} \linebreak
\url{https://code.google.com/p/sp2013-csc668-868-group1/}
\end{center}
\thispagestyle{empty} % Suppress page number

\newpage \pagenumbering{roman}
\tableofcontents


\newpage \pagenumbering{arabic}
\section{Contributions} 

\subsection{Contributions by Robert Bierman}

\subsection{Contributions by Victor Woeltjen}

\subsection{Contributions by Kay Choi}

\subsection{Contributions by Steven Gimeno}

\subsection{Contributions by Jason Lum}

\subsection{Contributions by Ying Kit Ng}

\subsection{Contributions by Bianca Uy}


\newpage 
\section{Platform}

\subsection{OpenMRS}

\newpage 
\section{User guide}

\subsection{Rules}

\subsubsection{Creating a rule}

\subsubsection{Modifying an existing rule}

\subsection{Alerts}

\subsubsection{Patient dashboard}

\subsubsection{Patient summary}

\newpage 
\section{Use cases}

\subsection{Rule administration}

\subsection{Alerts}

\newpage 
\section{Sequence diagrams}

\newpage 
\section{Design overview}

	The DSS1 rule subsystem is incorporated into OpenMRS in a simple Client-Server fashion. The target implementation will feature client-side web pages which interact with the DSS1 rule subsystem on the server by way of DSSRuleService. Figure 
~\ref{fig:ARCHITECTURE} illustrates this interaction.

\tikzstyle{layer}=[rectangle, 
                   rounded corners,
                   draw=black, 
                   align=center,
                   anchor=north]
\tikzstyle{communicates}=[draw, ->, >=triangle 60]
\tikzstyle{boundary}=[draw, -, dashed]
\begin{figure}\begin{center}
\begin{tikzpicture}
\node (Client) [layer] { 
  \textbf{Client Pages}      \\
  Patient Summary \\
  Patient Dashboard \\
  DSS Rule Administration
};
\node (Boundary) [below=of Client, minimum width=3in] {};
\node [above=of Boundary.east] {\emph{Client}};
\node [below=of Boundary.east] {\emph{Server}};
\node (Service) [layer, below=of Boundary] { 
  \textbf{DSS Rule Service}  \\
  Run rules  \\
  List rules \\
  Add rules  \\
  Edit rules
};
\node (Interpreter) [layer, below=of Service] { 
  \textbf{DSS1 Interpreter}  \\
  Intrinsics  \\
  Evaluations \\
  Flow control
};
\path [communicates] (Client.300     ) -- (Service.65     ) {};
\path [communicates] (Service.115    ) -- (Client.240     ) {};
\path [communicates] (Service.295    ) -- (Interpreter.60 ) {};
\path [communicates] (Interpreter.120) -- (Service.245    ) {};
\path [boundary] (Boundary.180) -- (Boundary.0    ) {};
%\path [boundary]     (Boundary.west  ) -- (Boundary.east  ) {};
\end{tikzpicture}
\caption{Architecture overview}\label{fig:ARCHITECTURE}
\end{center}\end{figure}

The DSS Rule Service, in turn, utilizing the DSS1 Interpreter subsystem to run rules and report results.

While the DSS Rule Service runs on the server, its interface is exposed to client-side JavaScript code via DWR (Direct Web Remoting).

\subsection{Client pages}

Multiple client web pages interact with the DSS Rule Service.

\subsubsection{Patient summary}

The Patient Summary ({\texttt{patientsummary.jsp}) is  stand-alone page, reachable from a link on the Patient Dashboard. It is used primarily to contain major information about a patient (gender, age, WHO stage, etc.) The Patient Summary invokes the rule service via DWR to retrieve all alerts for the named target  \texttt{summary} and displays them below other patient information. 

\subsubsection{Patient Dashboard} 

The Patient Dashboard is the primary landing point for viewing patient information, and contains multiple tabs for this purpose. This extension inserts a link to the Patient Summary on the Patient Dashboard, and accompanies this with relevant alerts by invoking the rule service for the \texttt{dashboard} target.

See \texttt{org.openmrs.module.basicmodule.extension.html.PatientSummaryExtension}

\subsubsection {DSS Rule Administration}
Create DSS Rule (\texttt{dssRules.form}) provides a form where DSS source code can be entered and submitted to the rule service with a specific rule name. Consolidates the ability to create new rules, load existing rules, and edit rules in one form. Made accessible through an extension to the Administration menu.

\subsection{Rule service}

The DSSRuleService follows the facade design pattern to expose important functionality to clients. The high-level tasks that are relevant to client code are defined using a few simple methods which hide the details of compiling, interpreting, and managing the storage of rules. Specific functionality is detailed in table ~\ref{tab:RULE_SERVICE}.

\begin{table}
\begin{center}
\begin{tabular}{ l | p{1in} | p{2in} }
Method & Description & Details \\ \hline

\texttt{store(rule, code)}
&
Stores a rule (either as a new rule, or replacing an existing rule) with the given source code.
&
Invokes the Parser to convert source code to AST; 
Invokes the XMLBuilder to convert AST to DOM and save; 
Saves the original source to file system for subsequent retrieval; 
Stores the AST in memory for subsequent running.
\\ \hline

\texttt{load(rule)}
&
Load the source code for an existing rule.
&
Reads stored source code from the file system.
\\ \hline

\texttt{listRules()}
&
List all existing rules.
&
Returns a list of all stored rule names.
\\ \hline

\texttt{runRules(patientId, target)}
&
Get all alerts for the given target (“summary” or “dashboard”) as appropriate to the given patient.
&
For each rule:
Construct interpreter; 
Install intrinsics, including “alert” function which stores to a map;
Pre-define “patientId” for DSS1 program;
Run the interpreter on the rule.
Thereafter, pull all alerts appropriate to the target from the map.
\\ \hline

\end{tabular}
\end{center}
\caption{Methods exposed by the DSS Rule Service}
\label{tab:RULE_SERVICE}
\end{table}

\subsubsection{Rule storage}

\subsection{Interpreter}

The Interpreter is implemented with four distinct sub systems.
At the top level, \emph{flow control} is provided by the InterpreterVisitor, which is responsible for traversing the Abstract Syntax Tree. An \emph{execution context} is maintained to describe the running state of the system, including defined variables and functions. While tree traversal coordinates complex expressions, the actual \emph{evaluation} of expressions is itself implemented in a distinct set of classes representing the types available under DSS1. Finally, a library of \emph{intrinsic functions} is provided in order to mediate interactions with OpenMRS from running DSS1, as well as to provide certain convenience functions to DSS1 rule programmers.

\tikzstyle{system}=[rectangle,
                   thick, 
                   draw=black, 
                   align=center,
                   anchor=north]
\tikzstyle{connects}=[draw, ->, >=triangle 60]
\tikzstyle{observes}=[draw, ->, dashed, >=triangle 60]
\begin{figure}
\begin{center}
\begin{tikzpicture}[node distance=1.5in]
\node (FlowControl) [system] 
      {\textbf{Flow control}};
\node (Middle) [below=of FlowControl] {};
\node (ExecutionContext) [system, left=of Middle] 
      {\textbf{Execution context}};
\node (Evaluation) [system, below=of Middle] 
      {\textbf{Evaluation}};
\node (IntrinsicFunction) [system, right=of Middle] 
      {\textbf{Intrinsic functions}};
\draw [connects] (FlowControl) -- (ExecutionContext) {}
      node [midway,above,sloped] {Sets, gets state} ;
\draw [connects] (ExecutionContext) -- (Evaluation) {}
      node [midway,below,sloped] {Contains values} ;
\draw [connects] (ExecutionContext) -- (IntrinsicFunction) {}
      node [midway,below left,sloped] {Contains functions} ;
\draw [connects] (FlowControl) -- (IntrinsicFunction) {}
      node [midway,above,sloped] {Invokes} ;
\draw [connects] (IntrinsicFunction) -- (Evaluation) {}
      node [midway,below,sloped] {Yields values} ;
\draw [connects] (FlowControl) -- (Evaluation) {}
      node [midway,above,sloped] {Assembles complex expressions} ;
\end{tikzpicture}
\end{center}
\caption{High-level overview of the DSS1 Interpreter.}
\end{figure}

\subsubsection{Flow control}

	Flow control in the interpreter is implemented using the Visitor design pattern, traversing the Abstract Syntax Tree (AST) produced by the existing Compiler using an implementation of the provided ASTVisitor interface, performing computation as appropriate at every given node in the tree.

	The Visitor design pattern leverages double dispatch to decouple a data structure from the operations which can be performed while traversing this data structure. The Visitor calls an “accept” method on a node within the data structure, which is itself overloaded to call a more specific method on the Visitor itself; “visitBlockTree”, for example. This permits the external object – the Visitor – to implement behavior using the data structure's type hierarchy, without adding that specific behavior to those types directly.

	In the case of the Interpreter, the data structure is the AST, which describes a DSS1 program as a tree of elements – block (BlockTree), if statements (IfTree), et cetera. The Visitor is the IntepreterVisitor, which manages and performs the computation described by this program. This is done with the support of other underlying subsystems to describe variable state and perform type-specific evaluations, as described in the Architecture section.

	The class InterpreterVisitor acts as the center of a subsystem  responsible for high-level interpretation of the program, including flow control, and coordinating complex expressions.

\subsubsection{Execution context}

\subsubsection{Evaluation}

\subsubsection{Intrinsic functions}

% \section{External documentation}

\newpage 
\section{Package diagrams}

\newpage 
\section{Class diagrams}

\tikzstyle{class}=[rectangle, 
                   draw=black, 
                   rectangle split, 
                   rectangle split parts=3,
                   align=center,
                   anchor=north]
\tikzstyle{implements}=[draw, ->, >=open triangle 90]
\tikzstyle{aggregates}=[draw, <-, >=open diamond]
\tikzstyle{contains}=[draw, <-, >=diamond]

\begin{figure}
\begin{tikzpicture}[node distance=0.25in]
\node (ASTVisitor) [class] { 
  \emph{ASTVisitor}
  \nodepart{second}  
  \nodepart[align=justify]{third}
  + visitBlockTree(t : AST) \\
  + visitIdTree(t : AST)    \\
  ...
};
\node (InterpreterVisitor) [class, below=of ASTVisitor] { 
  \textbf{InterpreterVisitor}
  \nodepart{second}  
  \nodepart[align=justify]{third}
};

\node (DSSExecutionContext) [class, right=of InterpreterVisitor] { 
  \textbf{DSSExecutionContext}
  \nodepart{second}  
  \nodepart[align=justify]{third}
  + setConstant(name : String,  value : DSSValue) \\
  + setIntrinsic(name : String,  func : DSSFunction)
};
\node (ExecutionContext) [class, above=of DSSExecutionContext] { 
  \textbf{ExecutionContext}
  \nodepart[align=justify]{second}  
  - evaluator : Evaluator
  \nodepart[align=justify]{third}
  + beginScope() \\
  + endScope() \\
  + getEvaluator() : Evaluator \\
  + getFunction(name : String) : DSSFunction \\
  + getReturnValue() : DSSValue \\
  + setReturnValue(v : DSSValue) \\
  + setFunction(name : String, f : DSSFunction)
};
\node (ASTInterpreter) [class, below=of InterpreterVisitor.south east] { 
  \emph{ASTInterpreter}
  \nodepart{second}  
  \nodepart[align=justify]{third}
  + interpret(ast : AST, 
              c : ExecutionContext, 
              v : ASTVisitor) \\ \hspace{10pt} : Object
};
\node (BlockInterpreter) [class, anchor=west, below=of ASTInterpreter] { 
  \textbf{BlockInterpreter}
  \nodepart{second}  
  \nodepart[align=justify]{third}
};
\node (IdInterpreter) [class, right=of ASTInterpreter] { 
  \textbf{IdInterpreter}
  \nodepart{second}  
  \nodepart[align=justify]{third}
};
\node (NamingContext) [class, above=of ExecutionContext] { 
  \emph{NamingContext}
  \nodepart[align=justify]{third}
  +set (name : String, value : DSSValue) \\
  +get (name : String) : DSSValue
};

\path [implements] (ExecutionContext) -- (NamingContext) {};
\path [implements] (InterpreterVisitor) -- (ASTVisitor) {};
\path [implements] (BlockInterpreter) -- (ASTInterpreter) {};
\path [implements] (IdInterpreter) -- (ASTInterpreter) {};
\path [implements] (DSSExecutionContext) -- (ExecutionContext) {};
\path [contains] (InterpreterVisitor) -- (DSSExecutionContext) {};
\path [contains] (InterpreterVisitor) -- (ASTInterpreter) {};
\draw (InterpreterVisitor) -- (ASTInterpreter) 
      node [midway, right] {\small{1..*}};
\draw (InterpreterVisitor) -- (DSSExecutionContext) 
      node [midway, above] {\small{1..1}};
\end{tikzpicture}
\caption{Interpreter visitor}
\end{figure}

\begin{figure}
\begin{tikzpicture}[node distance=0.33in]
\node (ExecutionContext) [class] { 
  \textbf{ExecutionContext}
  \nodepart[align=justify]{second}  
  - functions : Map\textless String, DSSFunction\textgreater \\
  - variables : Map\textless String, DSSValue\textgreater \\
  - evaluator : Evaluator
  \nodepart[align=justify]{third}
  + beginScope() \\
  + endScope() \\
  + getEvaluator() : Evaluator \\
  + getFunction(name : String) : DSSFunction \\
  + getReturnValue() : DSSValue \\
  + setReturnValue(v : DSSValue) \\
  + setFunction(name : String, f : DSSFunction)
};
\node (DSSValue) [class, right=of ExecutionContext] { 
  \emph{DSSValue}
  \nodepart[align=justify]{second}  
  - timestamp : Date
  \nodepart[align=justify]{third}
  + add (v : DSSValue) : DSSValue \\
  + sub (v : DSSValue) : DSSValue \\
  + div (v : DSSValue) : DSSValue \\
  ... \\
  + getTimeStamp() : Date
};
\node (NamingContext) [class, above=of ExecutionContext] { 
  \emph{NamingContext}
  \nodepart[align=justify]{third}
  +set (name : String, value : DSSValue) \\
  +get (name : String) : DSSValue
};
\node (DSSFunction) [class, right=of NamingContext] { 
  \emph{DSSFunction}
  \nodepart{second}  
  \nodepart[align=justify]{third}
  + call(args : DSSValue[]) : DSSValue \\
  + passAsIdentifier(argIndex : int) \\ \hspace{10pt} : boolean
};

\node (Evaluator) [class, below=of ExecutionContext] { 
  \emph{Evaluator}
  \nodepart{second}  
  \nodepart[align=justify]{third}
  + castTo(javaClass : Class, v : DSSValue) : Object \\
  + evaluate(leftOper : DSSValue, \\ 
    \hspace{10pt} operator : String, \\
    \hspace{10pt} rightOper : DSSValue) : DSSValue\\
  + evaluateLiteral(lit : Symbol) : DSSValue \\
  + newAllocation(fields : String[]) : DSSValue \\
  + toDSSValue(javaObject : Object) : DSSValue
};
\node (DSSEvaluator) [class, below=of Evaluator] { 
  \textbf{DSSEvaluator}
  \nodepart{second}  
  \nodepart[align=justify]{third}
};


\path [aggregates] (ExecutionContext) -- (DSSValue) {};
\path [aggregates] (ExecutionContext) -- (DSSFunction) {};
\path [contains] (ExecutionContext) -- (Evaluator) {};
\path [implements] (ExecutionContext) -- (NamingContext) {};
\path [implements] (DSSEvaluator) -- (Evaluator) {};
\draw (ExecutionContext) -- (DSSValue) 
      node [midway, above] {\small{1..*}};
\draw (ExecutionContext) -- (DSSFunction) 
      node [midway, below] {\small{1..*}};

\end{tikzpicture}
\caption{Execution context}
\end{figure}

\begin{figure}
\begin{tikzpicture}[node distance=0.25in]
\node (DSSValue) [class] { 
  \emph{DSSValue}
  \nodepart[align=justify]{second}  
  - timestamp : Date
  \nodepart[align=justify]{third}
  + add (v : DSSValue) : DSSValue \\
  + sub (v : DSSValue) : DSSValue \\
  + div (v : DSSValue) : DSSValue \\
  + mul (v : DSSValue) : DSSValue \\
  + power (v : DSSValue) : DSSValue \\
  + concat (v : DSSValue) : DSSValue \\
  + and (v : DSSValue) : DSSValue \\
  + or (v : DSSValue) : DSSValue \\
  + equal (v : DSSValue) : boolean \\
  + notequal (v : DSSValue) : boolean \\
  + lessthan (v : DSSValue) : boolean \\
  + greaterthan (v : DSSValue) : boolean \\
  + lessthanequal (v : DSSValue) : boolean \\
  + greaterthanequal (v : DSSValue) : boolean \\
  + getTimeStamp() : Date \\
  + setTimeStamp(date : Date)
};

\node (DSSValueNumeric) [class, right=of DSSValue.north east] {
  \emph{DSSValueNumeric}
  \nodepart[align=justify]{second}  
  \nodepart[align=justify]{third}
};
\node (DSSValueFloat) [class, above=of DSSValueNumeric] {
  \textbf{DSSValueFloat}
  \nodepart[align=justify]{second}  
  - value : double
  \nodepart[align=justify]{third}
};
\node (DSSValueInt) [class, below=of DSSValueNumeric] {
  \textbf{DSSValueInt}
  \nodepart[align=justify]{second}  
  - value : long
  \nodepart[align=justify]{third}
};
\node (DSSValueBool) [class, below=of DSSValueInt] {
  \textbf{DSSValueBool}
  \nodepart[align=justify]{second}  
  - value : boolean
  \nodepart[align=justify]{third}
};
\node (DSSValueString) [class, below=of DSSValueBool] {
  \textbf{DSSValueString}
  \nodepart[align=justify]{second}  
  - value : String
  \nodepart[align=justify]{third}
};
\node (DSSValueList) [class, below=of DSSValueString] {
  \textbf{DSSValueList}
  \nodepart[align=justify]{second}  
  - value : List
  \nodepart[align=justify]{third}
};
\node (DSSValueObject) [class, below=of DSSValue] {
  \textbf{DSSValueObject}
  \nodepart[align=justify]{second}  
  - fields : Map\textless String, DSSValue\textgreater 
  \nodepart[align=justify]{third}
};
\node (DSSValueNull) [class, right=of DSSValueObject] {
  \textbf{DSSValueNull}
  \nodepart[align=justify]{second}  
  \nodepart[align=justify]{third}
};

\node (NamingContext) [class, below=of DSSValueObject] { 
  \emph{NamingContext}
  \nodepart[align=justify]{third}
  +set (name : String, value : DSSValue) \\
  +get (name : String) : DSSValue
};

\path [implements] (DSSValueInt) -- (DSSValueNumeric) {};
\path [implements] (DSSValueFloat) -- (DSSValueNumeric) {};
\path [implements] (DSSValueNumeric) -- (DSSValue) {};
\path [implements] (DSSValueBool) -- (DSSValue) {};
\path [implements] (DSSValueString) -- (DSSValue) {};
\path [implements] (DSSValueList) -- (DSSValue) {};
\path [implements] (DSSValueNull) -- (DSSValue) {};
\path [implements] (DSSValueObject) -- (DSSValue) {};
\path [implements] (DSSValueObject) -- (NamingContext) {};
\end{tikzpicture}
\caption{Values}
\end{figure}

\newpage 
\section{API documentation}

\end{document}